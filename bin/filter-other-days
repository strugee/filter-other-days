#!/bin/sh

# This file is part of filter-other-days.
#
# filter-other-days is free software: you can redistribute it and/or
# modify it under the terms of the GNU Affero General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# filter-other-days is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with filter-other-days.  If not, see
# <http://www.gnu.org/licenses/>.

# This script exclusively uses `grep -v` to ensure it never discards log entries from today, ever.
# The rationale is that it's better to receive irrelevant information than it is to miss relevant information.
#
# This design becomes security-critical in implementations of Artificial Ignorance.
#
# This file is split up into multiple sections - each one corresponds to one family of logfile timestamp styles

#
# HUMAN-READABLE
#
# E.g.:
#
#   Jan  1 03:44:00 hostname <message>
#   January  1 03:44:00 hostname <message>
#   Jan  01 03:44:00 hostname <message>
#   January  01 03:44:00 hostname <message>
#

# Base dataset

FULL_MONTHS="January
February
March
April
May
June
July
August
September
October
November
December"

SHORT_MONTHS=$(echo "$FULL_MONTHS" | cut -c -3)

FULL_DAYS=$(seq 31 | sed 's/^/0/g' | sed 's/0\(..\)/\1/g')
DAYS=$(seq 31)
ALL_DAYS=$(echo "$FULL_DAYS\n$DAYS" | sort | uniq)

# Current values

NOW_SHORT_MONTH=$(date +%b)
NOW_FULL_MONTH=$(date +%B)
NOW_FULL_DAY=$(date +%d)
NOW_DAY=$(echo $NOW_FULL_DAY | sed 's/^0//')

# Filtered dataset

OTHER_SHORT_MONTHS=$(echo "$SHORT_MONTHS" | grep -Fxv $NOW_SHORT_MONTH)
OTHER_FULL_MONTHS=$(echo "$FULL_MONTHS" | grep -Fxv $NOW_FULL_MONTH)
OTHER_DAYS=$(echo "$DAYS" | grep -Fxv $NOW_DAY)
OTHER_FULL_DAYS=$(echo "$FULL_DAYS" | grep -Fxv $NOW_FULL_DAY)
OTHER_ALL_DAYS=$(echo "$OTHER_FULL_DAYS\n$OTHER_DAYS" | sort | uniq)

# Built regexps

# Unquoted on purpose so the shell turns newlines into spaces
FULL_MONTHS_REGEX=$(echo $OTHER_FULL_MONTHS | sed 's/ /\\|/g')
SHORT_MONTHS_REGEX=$(echo $OTHER_SHORT_MONTHS | sed 's/ /\\|/g')
ALL_DAYS_REGEX=$(echo $ALL_DAYS | sed 's/ /\\|/g')
DAY_REGEX=$(echo $OTHER_ALL_DAYS | sed 's/ /\\|/g')

#
# STANDARD
#
# E.g.:
#
#   2017-01-01 06:12:18 <message>
#

STANDARD_YEARS=$(seq 2000 2019)
STANDARD_MONTHS_NUM=$(seq 12)

NOW_YEAR=$(date +%Y)
NOW_MONTH_NUM=$(date +%m)

OTHER_MONTHS_NUM=$(echo "$STANDARD_MONTHS_NUM" | grep -v $NOW_MONTH_NUM)

YEARS_REGEX=$(echo $STANDARD_YEARS | sed 's/ /\\|/g')
STANDARD_MONTHS_REGEX=$(echo $OTHER_MONTHS_NUM | sed 's/ /\\|/g')

#
# ACTUAL `grep` INVOCATION
#

# We have to do the human-readable variants in two passes because we can't exclude today's day for other months
# E.g. if it's October 1st, we still want to match September 1st so we use $ALL_DAYS_REGEX, not $DAYS_REGEX
# Also I have literally no idea why the second regex has to use capturing groups. Whatever.
grep -v \
-e "\(:?$FULL_MONTHS_REGEX\|$SHORT_MONTHS_REGEX\)[[:space:]]\+\(:?$ALL_DAYS_REGEX\)" \
-e "\($NOW_SHORT_MONTH\|$NOW_FULL_MONTH\)[[:space:]]\+\(:?$DAY_REGEX\)" \
-e "\($YEARS_REGEX\)-\($STANDARD_MONTHS_REGEX\)-\($ALL_DAYS_REGEX\)" \
-e "\($YEARS_REGEX\)-$NOW_MONTH_NUM-\($DAY_REGEX\)"
